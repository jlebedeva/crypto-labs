package jlebedeva.week6;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.charset.Charset;
import javax.xml.bind.DatatypeConverter;
import javolution.text.Text;
import org.jscience.mathematics.number.LargeInteger;

/**
 * Programming Assignment Week 6 Your goal in this project is to break RSA when
 * the public modulus N is generated incorrectly. This should serve as yet
 * another reminder not to implement crypto primitives yourself.
 * 
 * Normally, the primes that comprise an RSA modulus are generated independently
 * of one another. But suppose a developer decides to generate the first prime p
 * by choosing a random number R and scanning for a prime close by. The second
 * prime q is generated by scanning for some other random prime also close to R.
 * We show that the resulting RSA modulus N=pq can be easily factored.
 * 
 * Suppose you are given a composite N and are told that N is a product of two
 * relatively close primes p and q, namely p and q satisfy^ |p−q|< 2*N^1/4 (*)
 * Your goal is to factor N.
 *
 * Let A be the arithmetic average of the two primes, that is A=(p+q)/2. Since p
 * and q are odd, we know that p+q is even and therefore A is an integer. To
 * factor N you first observe that under condition (*) the quantity N^(1/2) is
 * very close to A. In particular A−N^(1/2)<1. But since A is an integer,
 * rounding N^(1/2) up to the closest integer reveals the value of A. In code,
 * A=ceil(sqrt(N)) where "ceil" is the ceiling function.
 *
 * Since A is the exact mid-point between p and q there is an integer x such
 * that p=A−x and q=A+x. But then N=pq=(A−x)(A+x)=A^2−x^2 and therefore
 * x=(A^2−N)^(1/2). Now, given x and A you can find the factors p and q of N
 * since p=A−x and q=A+x.
 * 
 * The only remaining mystery is why A−N^(1/2)<1. This follows from the following
 * simple calculation. First observe that
 * 
 * A^2−N=(((p+q)/2)^2)−N=((p^2+2N+q^2)/4)−N=(p^2−2N+q^2)/4=((p−q)^2)/4
 * Now, since for all x,y: (x−y)(x+y)=x^2−y^2 we obtain
 * 
 * A−N^(1/2)=A−N^(1/2) * ((A+N^(1/2))/(A+N^(1/2)))=(A^2−N)/(A+N^(1/2))=((p−q)^2)/4(A−N^(1/2))
 * and since N^(1/2)≤A it follows that
 * 
 * A−N^(1/2)≤(p−q)^2/8N^(1/2)
 * By assumption we know that (p−q)^2<4N^(1/2) and therefore
 * 
 * 4N^(1/2)/8N^(1/2)=1/2 as required.
 */

public class Main {

    /**
     * @param args the command line arguments
     */
    private static BigInteger N_challenge1 = new BigInteger(
            "17976931348623159077293051907890247336179769789423065727343008115"
            + "77326758055056206869853794492129829595855013875371640157101398586"
            + "47833778606925583497541085196591615128057575940752635007475935288"
            + "71082364994994077189561705436114947486504671101510156394068052754"
            + "0071584560878577663743040086340742855278549092581");

    private static BigInteger N_challenge2 = new BigInteger(
            "6484558428080716696628242653467722787263437207069762630604390703787"
            + "9730861808111646271401527606141756919558732184025452065542490671989"
            + "2428844841839353281972988531310511738648965962582821502504990264452"
            + "1008852816733037111422964210278402893076574586452336833570778346897"
            + "15838646088239640236866252211790085787877");
    private static BigInteger N_challenge3 = new BigInteger(
            "72006226374735042527956443552558373833808445147399984182665305798191"
            + "63556901883377904234086641876639384851752649940178970835240791356868"
            + "77441155132015188279331812309091996246361896836573643119174094961348"
            + "52463970788523879939683923036467667022162701835329944324119217381272"
            + "9276147530748597302192751375739387929");
    
    private static BigInteger ciphertext_challenge4 = new BigInteger(
            "22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540");
    
    public static void main(String[] args) throws UnsupportedEncodingException {
        LargeInteger[] factors = challenge1();
        challenge2();
        challenge3();
        challenge4(factors);
    }
    
    /**
     * Factoring challenge #1: The following modulus N is a products of two
     * primes p and q where |p−q|<2*N^(1/4). Find the smaller of the two factors and
     * enter it as a decimal integer.
     */
    private static LargeInteger[] challenge1() {
        LargeInteger N = LargeInteger.valueOf(N_challenge1);
        LargeInteger A = findBottomOfArithmeticAverage(N).plus(1);
        LargeInteger[] factors = findPossibleFactors(A, N);
        report(N, factors[0], factors[1]);
        return new LargeInteger[] {factors[0], factors[1]};
    }
    /**
     * Factoring challenge #2: The following modulus N is a products of two
     * primes p and q where |p−q|<2^11 * N^(1/4). Find the smaller of the two factors
     * and enter it as a decimal integer. Hint: in this case A−N^(1/2) < 2^20 so try
     * scanning for A from N^(1/2) upwards, until you succeed in factoring N.
     */
    private static void challenge2() {
        LargeInteger N = LargeInteger.valueOf(N_challenge2);
        LargeInteger possible_A = findBottomOfArithmeticAverage(N);
        LargeInteger[] factors;
        for (int i = 1; i < 1048576 /*top is 2^20*/; i++) {
             factors = findPossibleFactors(possible_A.plus(i), N);
            if (areFactors(N, factors[0],factors[1])) {
                report(N, factors[0], factors[1]);
                break;
            }
        }
    }
    /**
     * Factoring challenge #3: (extra credit) The following modulus N is a
     * products of two primes p and q where |3p−2q|<N1/4. Find the smaller of
     * the two factors and enter it as a decimal integer. Hint: use the
     * calculation below to show that 6N−−−√ is close to 3p+2q2 and then adapt
     * the method above to factor N.
     * 
     * Big hint: make A = (3p + 2q) and find factors of 24N
     */
    private static LargeInteger[] challenge3() {
        LargeInteger N = LargeInteger.valueOf(N_challenge3);
        LargeInteger N_toFactor = N.times(24);
        LargeInteger A = findBottomOfArithmeticAverage(N_toFactor).plus(1);
        LargeInteger[] factors = findPossibleFactors(A, N_toFactor);
        /**
         * 24N = 6p * 4q
         * p and q are primes
         * 3p is odd and 2q is even
         */
        LargeInteger p = null;
        LargeInteger q = null;
        boolean firstIsEven = factors[0].divide(2).isEven();
        boolean secondIsEven = factors[1].divide(2).isEven();
        if (firstIsEven && !secondIsEven) {
            q = factors[0].divide(4);
            p = factors[1].divide(6);
        } else if (!firstIsEven && secondIsEven) {
            q = factors[1].divide(4);
            p = factors[0].divide(6);
        }
        if (q.isLargerThan(p)) {
            report(N, p, q);
        } else {
            report(N, q, p);
        }
        return new LargeInteger[] {p, q};
    }
    /**
     * RSA modulo 1 challenge
     */
    private static void challenge4(LargeInteger[] factors) throws UnsupportedEncodingException {
        LargeInteger N = LargeInteger.valueOf(N_challenge1);
        LargeInteger fy = N.minus(factors[0]).minus(factors[1]).plus(1);
        LargeInteger e = LargeInteger.valueOf(65537);
        LargeInteger d = e.modInverse(fy);
        LargeInteger decrypted = LargeInteger.valueOf(ciphertext_challenge4).modPow(d, N);
        Text hex = decrypted.toText(16);
        String hexText = hex.subtext(hex.indexOf("00") + 2).toString();
        System.out.println(hexText);
        System.out.println(new String(DatatypeConverter.parseHexBinary(hexText), "ISO-8859-1"));
        
    }
    
    private static void report(LargeInteger N, LargeInteger lesserFactor, LargeInteger greaterFactor) {
        System.out.println("Challenge: " + N);
        System.out.println("Lesser factor: " + lesserFactor);
        System.out.println("Greater factor: " + greaterFactor);
        System.out.println("Answer is right: " + areFactors(N, lesserFactor, greaterFactor));
    }
    
    private static boolean areFactors(LargeInteger N, LargeInteger lesserFactor, LargeInteger greaterFactor) {
        return lesserFactor.times(greaterFactor).equals(N);
    }
    
    private static LargeInteger findBottomOfArithmeticAverage(LargeInteger N) {
        return N.sqrt();
    }
    
    private static LargeInteger[] findPossibleFactors(LargeInteger A, LargeInteger N) {
        LargeInteger delta = A.pow(2).minus(N).sqrt();
        return new LargeInteger[] {A.minus(delta), A.plus(delta)};
    }
}
